// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.10.0+v0.29.4
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
namespace uniffi.cider_core;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            var buffer = _UniFFILib.ffi_cider_core_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.ffi_cider_core_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
public class UniffiException: System.Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

internal class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

internal class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

internal class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

internal class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

internal class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

internal class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

internal class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: System.Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}

static class FFIObjectUtil {
    public static void DisposeAll(params Object?[] list) {
        Dispose(list);
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
   private static void Dispose(Object? obj) {
         if (obj == null) {
             return;
         }

         if (obj is IDisposable disposable) {
             disposable.Dispose();
             return;
         }

         var objType = obj.GetType();
         var typeCode = Type.GetTypeCode(objType);
         if (typeCode != TypeCode.Object) {
             return;
         }

         var genericArguments = objType.GetGenericArguments();
         if (genericArguments.Length == 0 && !objType.IsArray) {
             return;
         }

         if (obj is System.Collections.IDictionary objDictionary) {
             //This extra code tests to not call "Dispose" for a Dictionary<something, double>()
             //for all values as "double" and alike doesn't support interface "IDisposable"
             var valuesType = objType.GetGenericArguments()[1];
             var elementValuesTypeCode = Type.GetTypeCode(valuesType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in objDictionary.Values) {
                 Dispose(value);
             }
         }
         else if (obj is System.Collections.IEnumerable listValues) {
             //This extra code tests to not call "Dispose" for a List<int>()
             //for all keys as "int" and alike doesn't support interface "IDisposable"
             var elementType = objType.IsArray ? objType.GetElementType() : genericArguments[0];
             var elementValuesTypeCode = Type.GetTypeCode(elementType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in listValues) {
                 Dispose(value);
             }
         }
     }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: System.Exception {
    public StreamUnderflowException() {
    }
}

static class BigEndianStreamExtensions
{
    public static void WriteInt32(this Stream stream, int value, int bytesToWrite = 4)
    {
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
        byte[] buffer = new byte[bytesToWrite];
#endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static void WriteInt64(this Stream stream, long value)
    {
        int bytesToWrite = 8;
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToWrite];
 #else
         byte[] buffer = new byte[bytesToWrite];
 #endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static uint ReadUint32(this Stream stream, int bytesToRead = 4) {
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        uint result = 0;
        uint digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static ulong ReadUInt64(this Stream stream) {
        int bytesToRead = 8;
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        ulong result = 0;
        ulong digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static void CheckRemaining(this Stream stream, int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }

    public static void ForEach<T>(this T[] items, Action<T> action){
        foreach (var item in items) {
            action(item);
        }
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] buffer) {
#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public void WriteByte(byte value) => stream.WriteInt32(value, bytesToWrite: 1);
    public void WriteSByte(sbyte value) => stream.WriteInt32(value, bytesToWrite: 1);

    public void WriteUShort(ushort value) => stream.WriteInt32(value, bytesToWrite: 2);
    public void WriteShort(short value) => stream.WriteInt32(value, bytesToWrite: 2);

    public void WriteUInt(uint value) => stream.WriteInt32((int)value);
    public void WriteInt(int value) => stream.WriteInt32(value);

    public void WriteULong(ulong value) => stream.WriteInt64((long)value);
    public void WriteLong(long value) => stream.WriteInt64(value);

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }
    public void WriteDouble(double value) => stream.WriteInt64(BitConverter.DoubleToInt64Bits(value));

    public byte[] ReadBytes(int length) {
        stream.CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() => (byte)stream.ReadUint32(bytesToRead: 1);
    public ushort ReadUShort() => (ushort)stream.ReadUint32(bytesToRead: 2);
    public uint ReadUInt() => (uint)stream.ReadUint32(bytesToRead: 4);
    public ulong ReadULong() => stream.ReadUInt64();

    public sbyte ReadSByte() => (sbyte)ReadByte();
    public short ReadShort() => (short)ReadUShort();
    public int ReadInt() => (int)ReadUInt();

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() => (long)ReadULong();
    public double ReadDouble() => BitConverter.Int64BitsToDouble(ReadLong());
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib {
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(
        ulong @data,sbyte @pollResult
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(
        ulong @handle
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(
        ulong @handle
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructPointer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructVoid @result
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod0(
        ulong @uniffiHandle,RustBuffer @state,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod1(
        ulong @uniffiHandle,RustBuffer @track,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod2(
        ulong @uniffiHandle,RustBuffer @playback,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod3(
        ulong @uniffiHandle,RustBuffer @participant,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod4(
        ulong @uniffiHandle,RustBuffer @peerId,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod5(
        ulong @uniffiHandle,RustBuffer @reason,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod6(
        ulong @uniffiHandle,RustBuffer @message,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod7(
        ulong @uniffiHandle,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod8(
        ulong @uniffiHandle,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSessionCallbackMethod9(
        ulong @uniffiHandle,RustBuffer @status,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceSessionCallback
    {
        public IntPtr @onRoomStateChanged;
        public IntPtr @onTrackChanged;
        public IntPtr @onPlaybackChanged;
        public IntPtr @onParticipantJoined;
        public IntPtr @onParticipantLeft;
        public IntPtr @onRoomEnded;
        public IntPtr @onError;
        public IntPtr @onConnected;
        public IntPtr @onDisconnected;
        public IntPtr @onSyncStatus;
        public IntPtr @uniffiFree;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        UniffiCallbackInterfaceSessionCallback.Register();
        }

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_cider_core_fn_clone_session(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_free_session(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_cider_core_fn_constructor_session_new(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_broadcast_playback(IntPtr @ptr,RustBuffer @track,sbyte @isPlaying,ulong @positionMs,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_broadcast_track_change(IntPtr @ptr,RustBuffer @track,ulong @positionMs,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_check_cider_connection(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_cider_core_fn_method_session_create_room(IntPtr @ptr,RustBuffer @displayName,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_cider_core_fn_method_session_get_is_playing(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_cider_core_fn_method_session_get_now_playing(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_cider_core_fn_method_session_get_playback_state(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_cider_core_fn_method_session_get_room_state(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_cider_core_fn_method_session_is_host(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_cider_core_fn_method_session_is_in_room(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_join_room(IntPtr @ptr,RustBuffer @roomCode,RustBuffer @displayName,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_leave_room(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_set_callback(IntPtr @ptr,ulong @callback,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_set_cider_token(IntPtr @ptr,RustBuffer @token,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_sync_next(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_sync_pause(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_sync_play(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_sync_previous(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_sync_seek(IntPtr @ptr,ulong @positionMs,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_method_session_transfer_host(IntPtr @ptr,RustBuffer @peerId,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_cider_core_fn_init_callback_vtable_sessioncallback(ref _UniFFILib.UniffiVTableCallbackInterfaceSessionCallback @vtable
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_cider_core_rustbuffer_alloc(ulong @size,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_cider_core_rustbuffer_from_bytes(ForeignBytes @bytes,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rustbuffer_free(RustBuffer @buf,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_cider_core_rustbuffer_reserve(RustBuffer @buf,ulong @additional,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_u8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_cider_core_rust_future_complete_u8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_i8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_cider_core_rust_future_complete_i8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_u16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_cider_core_rust_future_complete_u16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_i16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_cider_core_rust_future_complete_i16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_u32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_cider_core_rust_future_complete_u32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_i32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_cider_core_rust_future_complete_i32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_u64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_cider_core_rust_future_complete_u64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_i64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_cider_core_rust_future_complete_i64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_f32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_cider_core_rust_future_complete_f32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_f64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_cider_core_rust_future_complete_f64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_pointer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_cider_core_rust_future_complete_pointer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_cider_core_rust_future_complete_rust_buffer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_poll_void(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_free_void(IntPtr @handle
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_cider_core_rust_future_complete_void(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_broadcast_playback(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_broadcast_track_change(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_check_cider_connection(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_create_room(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_get_is_playing(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_get_now_playing(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_get_playback_state(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_get_room_state(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_is_host(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_is_in_room(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_join_room(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_leave_room(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_set_callback(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_set_cider_token(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_sync_next(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_sync_pause(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_sync_play(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_sync_previous(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_sync_seek(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_session_transfer_host(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_constructor_session_new(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_room_state_changed(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_track_changed(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_playback_changed(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_participant_joined(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_participant_left(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_room_ended(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_error(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_connected(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_disconnected(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_cider_core_checksum_method_sessioncallback_on_sync_status(
    );

    [DllImport("cider_core", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_cider_core_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_cider_core_uniffi_contract_version();
        if (29 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"uniffi.cider_core: uniffi bindings expected version `29`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_broadcast_playback();
            if (checksum != 49795) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_broadcast_playback` checksum `49795`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_broadcast_track_change();
            if (checksum != 36013) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_broadcast_track_change` checksum `36013`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_check_cider_connection();
            if (checksum != 54359) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_check_cider_connection` checksum `54359`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_create_room();
            if (checksum != 63668) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_create_room` checksum `63668`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_get_is_playing();
            if (checksum != 24018) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_get_is_playing` checksum `24018`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_get_now_playing();
            if (checksum != 24844) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_get_now_playing` checksum `24844`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_get_playback_state();
            if (checksum != 29211) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_get_playback_state` checksum `29211`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_get_room_state();
            if (checksum != 61756) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_get_room_state` checksum `61756`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_is_host();
            if (checksum != 23213) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_is_host` checksum `23213`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_is_in_room();
            if (checksum != 49720) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_is_in_room` checksum `49720`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_join_room();
            if (checksum != 19987) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_join_room` checksum `19987`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_leave_room();
            if (checksum != 60146) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_leave_room` checksum `60146`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_set_callback();
            if (checksum != 55902) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_set_callback` checksum `55902`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_set_cider_token();
            if (checksum != 49915) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_set_cider_token` checksum `49915`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_sync_next();
            if (checksum != 18357) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_sync_next` checksum `18357`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_sync_pause();
            if (checksum != 6232) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_sync_pause` checksum `6232`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_sync_play();
            if (checksum != 24935) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_sync_play` checksum `24935`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_sync_previous();
            if (checksum != 26314) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_sync_previous` checksum `26314`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_sync_seek();
            if (checksum != 54577) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_sync_seek` checksum `54577`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_session_transfer_host();
            if (checksum != 44133) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_session_transfer_host` checksum `44133`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_constructor_session_new();
            if (checksum != 7363) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_constructor_session_new` checksum `7363`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_room_state_changed();
            if (checksum != 37933) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_room_state_changed` checksum `37933`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_track_changed();
            if (checksum != 7828) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_track_changed` checksum `7828`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_playback_changed();
            if (checksum != 28967) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_playback_changed` checksum `28967`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_participant_joined();
            if (checksum != 28402) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_participant_joined` checksum `28402`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_participant_left();
            if (checksum != 25130) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_participant_left` checksum `25130`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_room_ended();
            if (checksum != 12494) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_room_ended` checksum `12494`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_error();
            if (checksum != 33220) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_error` checksum `33220`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_connected();
            if (checksum != 25547) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_connected` checksum `25547`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_disconnected();
            if (checksum != 6877) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_disconnected` checksum `6877`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_cider_core_checksum_method_sessioncallback_on_sync_status();
            if (checksum != 16815) {
                throw new UniffiContractChecksumException($"uniffi.cider_core: uniffi bindings expected function `uniffi_cider_core_checksum_method_sessioncallback_on_sync_status` checksum `16815`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt64: FfiConverter<ulong, ulong> {
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value) {
        return value;
    }

    public override ulong Read(BigEndianStream stream) {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value) {
        return value;
    }

    public override int AllocationSize(ulong value) {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream) {
        stream.WriteULong(value);
    }
}



class FfiConverterInt64: FfiConverter<long, long> {
    public static FfiConverterInt64 INSTANCE = new FfiConverterInt64();

    public override long Lift(long value) {
        return value;
    }

    public override long Read(BigEndianStream stream) {
        return stream.ReadLong();
    }

    public override long Lower(long value) {
        return value;
    }

    public override int AllocationSize(long value) {
        return 8;
    }

    public override void Write(long value, BigEndianStream stream) {
        stream.WriteLong(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}



/// <summary>
/// Main session interface
/// </summary>
internal interface ISession {
    /// <summary>
    /// Broadcast current playback state to room (for host heartbeat)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void BroadcastPlayback(TrackInfo? @track, bool @isPlaying, ulong @positionMs);
    /// <summary>
    /// Broadcast track change to room (for host when track changes)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void BroadcastTrackChange(TrackInfo @track, ulong @positionMs);
    /// <summary>
    /// Check if Cider is reachable
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void CheckCiderConnection();
    /// <summary>
    /// Create a new room (become host)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    string CreateRoom(string @displayName);
    /// <summary>
    /// Check if Cider is currently playing
    /// </summary>
    /// <exception cref="CoreException"></exception>
    bool GetIsPlaying();
    /// <summary>
    /// Get the currently playing track from Cider
    /// </summary>
    /// <exception cref="CoreException"></exception>
    TrackInfo? GetNowPlaying();
    /// <summary>
    /// Get playback state (track info + is_playing) in a single call
    /// </summary>
    /// <exception cref="CoreException"></exception>
    CurrentPlayback GetPlaybackState();
    /// <summary>
    /// Get current room state
    /// </summary>
    RoomState? GetRoomState();
    /// <summary>
    /// Check if we are the host
    /// </summary>
    bool IsHost();
    /// <summary>
    /// Check if we are in a room
    /// </summary>
    bool IsInRoom();
    /// <summary>
    /// Join an existing room
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void JoinRoom(string @roomCode, string @displayName);
    /// <summary>
    /// Leave the current room
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void LeaveRoom();
    /// <summary>
    /// Set the event callback
    /// </summary>
    void SetCallback(SessionCallback @callback);
    /// <summary>
    /// Set the Cider API token
    /// </summary>
    void SetCiderToken(string? @token);
    /// <summary>
    /// Sync next command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void SyncNext();
    /// <summary>
    /// Sync pause command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void SyncPause();
    /// <summary>
    /// Sync play command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void SyncPlay();
    /// <summary>
    /// Sync previous command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void SyncPrevious();
    /// <summary>
    /// Sync seek command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void SyncSeek(ulong @positionMs);
    /// <summary>
    /// Transfer host to another peer
    /// </summary>
    /// <exception cref="CoreException"></exception>
    void TransferHost(string @peerId);
}
/// <summary>
/// Main session interface
/// </summary>
public class Session : ISession, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Session(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~Session() {
        Destroy();
    }
    /// <summary>
    /// Create a new session
    /// </summary>
    public Session() :
        this(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_constructor_session_new( ref _status)
)) {}

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_cider_core_fn_free_session(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_cider_core_fn_clone_session(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Broadcast current playback state to room (for host heartbeat)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void BroadcastPlayback(TrackInfo? @track, bool @isPlaying, ulong @positionMs) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_broadcast_playback(thisPtr, FfiConverterOptionalTypeTrackInfo.INSTANCE.Lower(@track), FfiConverterBoolean.INSTANCE.Lower(@isPlaying), FfiConverterUInt64.INSTANCE.Lower(@positionMs), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Broadcast track change to room (for host when track changes)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void BroadcastTrackChange(TrackInfo @track, ulong @positionMs) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_broadcast_track_change(thisPtr, FfiConverterTypeTrackInfo.INSTANCE.Lower(@track), FfiConverterUInt64.INSTANCE.Lower(@positionMs), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Check if Cider is reachable
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void CheckCiderConnection() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_check_cider_connection(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Create a new room (become host)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public string CreateRoom(string @displayName) {
        return CallWithPointer(thisPtr => FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_create_room(thisPtr, FfiConverterString.INSTANCE.Lower(@displayName), ref _status)
)));
    }
    
    
    /// <summary>
    /// Check if Cider is currently playing
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public bool GetIsPlaying() {
        return CallWithPointer(thisPtr => FfiConverterBoolean.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_get_is_playing(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the currently playing track from Cider
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public TrackInfo? GetNowPlaying() {
        return CallWithPointer(thisPtr => FfiConverterOptionalTypeTrackInfo.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_get_now_playing(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get playback state (track info + is_playing) in a single call
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public CurrentPlayback GetPlaybackState() {
        return CallWithPointer(thisPtr => FfiConverterTypeCurrentPlayback.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_get_playback_state(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get current room state
    /// </summary>
    public RoomState? GetRoomState() {
        return CallWithPointer(thisPtr => FfiConverterOptionalTypeRoomState.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_get_room_state(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Check if we are the host
    /// </summary>
    public bool IsHost() {
        return CallWithPointer(thisPtr => FfiConverterBoolean.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_is_host(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Check if we are in a room
    /// </summary>
    public bool IsInRoom() {
        return CallWithPointer(thisPtr => FfiConverterBoolean.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_is_in_room(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Join an existing room
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void JoinRoom(string @roomCode, string @displayName) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_join_room(thisPtr, FfiConverterString.INSTANCE.Lower(@roomCode), FfiConverterString.INSTANCE.Lower(@displayName), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Leave the current room
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void LeaveRoom() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_leave_room(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Set the event callback
    /// </summary>
    public void SetCallback(SessionCallback @callback) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_set_callback(thisPtr, FfiConverterTypeSessionCallback.INSTANCE.Lower(@callback), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Set the Cider API token
    /// </summary>
    public void SetCiderToken(string? @token) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_set_cider_token(thisPtr, FfiConverterOptionalString.INSTANCE.Lower(@token), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Sync next command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void SyncNext() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_sync_next(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Sync pause command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void SyncPause() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_sync_pause(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Sync play command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void SyncPlay() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_sync_play(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Sync previous command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void SyncPrevious() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_sync_previous(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Sync seek command (host only)
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void SyncSeek(ulong @positionMs) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_sync_seek(thisPtr, FfiConverterUInt64.INSTANCE.Lower(@positionMs), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Transfer host to another peer
    /// </summary>
    /// <exception cref="CoreException"></exception>
    public void TransferHost(string @peerId) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeCoreError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_cider_core_fn_method_session_transfer_host(thisPtr, FfiConverterString.INSTANCE.Lower(@peerId), ref _status)
));
    }
    
    
    

    
}
class FfiConverterTypeSession: FfiConverter<Session, IntPtr> {
    public static FfiConverterTypeSession INSTANCE = new FfiConverterTypeSession();


    public override IntPtr Lower(Session value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Session Lift(IntPtr value) {
        return new Session(value);
    }

    public override Session Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Session value) {
        return 8;
    }

    public override void Write(Session value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// A calibration sample for debug display
/// </summary>
/// <param name="drift_ms">
/// Drift measured after seek (positive = ahead, negative = behind)
/// </param>
/// <param name="ideal_offset_ms">
/// The ideal offset this sample suggested
/// </param>
/// <param name="new_offset_ms">
/// The offset after applying this sample
/// </param>
/// <param name="rejected">
/// Whether this sample was rejected as outlier
/// </param>
public record CalibrationSample (
    /// <summary>
    /// Drift measured after seek (positive = ahead, negative = behind)
    /// </summary>
    long @driftMs, 
    /// <summary>
    /// The ideal offset this sample suggested
    /// </summary>
    long @idealOffsetMs, 
    /// <summary>
    /// The offset after applying this sample
    /// </summary>
    ulong @newOffsetMs, 
    /// <summary>
    /// Whether this sample was rejected as outlier
    /// </summary>
    bool @rejected
) {
}

class FfiConverterTypeCalibrationSample: FfiConverterRustBuffer<CalibrationSample> {
    public static FfiConverterTypeCalibrationSample INSTANCE = new FfiConverterTypeCalibrationSample();

    public override CalibrationSample Read(BigEndianStream stream) {
        return new CalibrationSample(
            @driftMs: FfiConverterInt64.INSTANCE.Read(stream),
            @idealOffsetMs: FfiConverterInt64.INSTANCE.Read(stream),
            @newOffsetMs: FfiConverterUInt64.INSTANCE.Read(stream),
            @rejected: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CalibrationSample value) {
        return 0
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@driftMs)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@idealOffsetMs)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@newOffsetMs)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@rejected);
    }

    public override void Write(CalibrationSample value, BigEndianStream stream) {
            FfiConverterInt64.INSTANCE.Write(value.@driftMs, stream);
            FfiConverterInt64.INSTANCE.Write(value.@idealOffsetMs, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@newOffsetMs, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@rejected, stream);
    }
}



/// <summary>
/// Current playback info (for polling) exposed via FFI
/// </summary>
public record CurrentPlayback (
    TrackInfo? @track, 
    bool @isPlaying
) {
}

class FfiConverterTypeCurrentPlayback: FfiConverterRustBuffer<CurrentPlayback> {
    public static FfiConverterTypeCurrentPlayback INSTANCE = new FfiConverterTypeCurrentPlayback();

    public override CurrentPlayback Read(BigEndianStream stream) {
        return new CurrentPlayback(
            @track: FfiConverterOptionalTypeTrackInfo.INSTANCE.Read(stream),
            @isPlaying: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CurrentPlayback value) {
        return 0
            + FfiConverterOptionalTypeTrackInfo.INSTANCE.AllocationSize(value.@track)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isPlaying);
    }

    public override void Write(CurrentPlayback value, BigEndianStream stream) {
            FfiConverterOptionalTypeTrackInfo.INSTANCE.Write(value.@track, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isPlaying, stream);
    }
}



/// <summary>
/// Participant exposed via FFI
/// </summary>
public record Participant (
    string @peerId, 
    string @displayName, 
    bool @isHost
) {
}

class FfiConverterTypeParticipant: FfiConverterRustBuffer<Participant> {
    public static FfiConverterTypeParticipant INSTANCE = new FfiConverterTypeParticipant();

    public override Participant Read(BigEndianStream stream) {
        return new Participant(
            @peerId: FfiConverterString.INSTANCE.Read(stream),
            @displayName: FfiConverterString.INSTANCE.Read(stream),
            @isHost: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Participant value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@peerId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@displayName)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isHost);
    }

    public override void Write(Participant value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@peerId, stream);
            FfiConverterString.INSTANCE.Write(value.@displayName, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isHost, stream);
    }
}



/// <summary>
/// Playback state exposed via FFI
/// </summary>
public record PlaybackState (
    bool @isPlaying, 
    ulong @positionMs, 
    ulong @timestampMs
) {
}

class FfiConverterTypePlaybackState: FfiConverterRustBuffer<PlaybackState> {
    public static FfiConverterTypePlaybackState INSTANCE = new FfiConverterTypePlaybackState();

    public override PlaybackState Read(BigEndianStream stream) {
        return new PlaybackState(
            @isPlaying: FfiConverterBoolean.INSTANCE.Read(stream),
            @positionMs: FfiConverterUInt64.INSTANCE.Read(stream),
            @timestampMs: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PlaybackState value) {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isPlaying)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@positionMs)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@timestampMs);
    }

    public override void Write(PlaybackState value, BigEndianStream stream) {
            FfiConverterBoolean.INSTANCE.Write(value.@isPlaying, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@positionMs, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@timestampMs, stream);
    }
}



/// <summary>
/// Room state exposed via FFI
/// </summary>
public record RoomState (
    string @roomCode, 
    string @localPeerId, 
    string @hostPeerId, 
    Participant[] @participants, 
    TrackInfo? @currentTrack, 
    PlaybackState @playback
) {
}

class FfiConverterTypeRoomState: FfiConverterRustBuffer<RoomState> {
    public static FfiConverterTypeRoomState INSTANCE = new FfiConverterTypeRoomState();

    public override RoomState Read(BigEndianStream stream) {
        return new RoomState(
            @roomCode: FfiConverterString.INSTANCE.Read(stream),
            @localPeerId: FfiConverterString.INSTANCE.Read(stream),
            @hostPeerId: FfiConverterString.INSTANCE.Read(stream),
            @participants: FfiConverterSequenceTypeParticipant.INSTANCE.Read(stream),
            @currentTrack: FfiConverterOptionalTypeTrackInfo.INSTANCE.Read(stream),
            @playback: FfiConverterTypePlaybackState.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RoomState value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@roomCode)
            + FfiConverterString.INSTANCE.AllocationSize(value.@localPeerId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@hostPeerId)
            + FfiConverterSequenceTypeParticipant.INSTANCE.AllocationSize(value.@participants)
            + FfiConverterOptionalTypeTrackInfo.INSTANCE.AllocationSize(value.@currentTrack)
            + FfiConverterTypePlaybackState.INSTANCE.AllocationSize(value.@playback);
    }

    public override void Write(RoomState value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@roomCode, stream);
            FfiConverterString.INSTANCE.Write(value.@localPeerId, stream);
            FfiConverterString.INSTANCE.Write(value.@hostPeerId, stream);
            FfiConverterSequenceTypeParticipant.INSTANCE.Write(value.@participants, stream);
            FfiConverterOptionalTypeTrackInfo.INSTANCE.Write(value.@currentTrack, stream);
            FfiConverterTypePlaybackState.INSTANCE.Write(value.@playback, stream);
    }
}



/// <summary>
/// Sync status for debug display
/// </summary>
/// <param name="drift_ms">
/// Drift in milliseconds (positive = ahead of host, negative = behind)
/// </param>
/// <param name="latency_ms">
/// One-way latency to host in milliseconds
/// </param>
/// <param name="elapsed_ms">
/// Time elapsed since host's heartbeat timestamp
/// </param>
/// <param name="seek_offset_ms">
/// Calibrated seek offset for Cider buffer latency
/// </param>
/// <param name="calibration_pending">
/// Whether calibrator is waiting to measure after a seek
/// </param>
/// <param name="next_calibration_sample">
/// What the next calibration sample would be (if pending and not outlier)
/// None if not pending or would be rejected as outlier
/// </param>
/// <param name="sample_history">
/// Recent calibration samples (newest last)
/// </param>
public record SyncStatus (
    /// <summary>
    /// Drift in milliseconds (positive = ahead of host, negative = behind)
    /// </summary>
    long @driftMs, 
    /// <summary>
    /// One-way latency to host in milliseconds
    /// </summary>
    ulong @latencyMs, 
    /// <summary>
    /// Time elapsed since host's heartbeat timestamp
    /// </summary>
    ulong @elapsedMs, 
    /// <summary>
    /// Calibrated seek offset for Cider buffer latency
    /// </summary>
    ulong @seekOffsetMs, 
    /// <summary>
    /// Whether calibrator is waiting to measure after a seek
    /// </summary>
    bool @calibrationPending, 
    /// <summary>
    /// What the next calibration sample would be (if pending and not outlier)
    /// None if not pending or would be rejected as outlier
    /// </summary>
    long? @nextCalibrationSample, 
    /// <summary>
    /// Recent calibration samples (newest last)
    /// </summary>
    CalibrationSample[] @sampleHistory
) {
}

class FfiConverterTypeSyncStatus: FfiConverterRustBuffer<SyncStatus> {
    public static FfiConverterTypeSyncStatus INSTANCE = new FfiConverterTypeSyncStatus();

    public override SyncStatus Read(BigEndianStream stream) {
        return new SyncStatus(
            @driftMs: FfiConverterInt64.INSTANCE.Read(stream),
            @latencyMs: FfiConverterUInt64.INSTANCE.Read(stream),
            @elapsedMs: FfiConverterUInt64.INSTANCE.Read(stream),
            @seekOffsetMs: FfiConverterUInt64.INSTANCE.Read(stream),
            @calibrationPending: FfiConverterBoolean.INSTANCE.Read(stream),
            @nextCalibrationSample: FfiConverterOptionalInt64.INSTANCE.Read(stream),
            @sampleHistory: FfiConverterSequenceTypeCalibrationSample.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SyncStatus value) {
        return 0
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@driftMs)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@latencyMs)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@elapsedMs)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@seekOffsetMs)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@calibrationPending)
            + FfiConverterOptionalInt64.INSTANCE.AllocationSize(value.@nextCalibrationSample)
            + FfiConverterSequenceTypeCalibrationSample.INSTANCE.AllocationSize(value.@sampleHistory);
    }

    public override void Write(SyncStatus value, BigEndianStream stream) {
            FfiConverterInt64.INSTANCE.Write(value.@driftMs, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@latencyMs, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@elapsedMs, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@seekOffsetMs, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@calibrationPending, stream);
            FfiConverterOptionalInt64.INSTANCE.Write(value.@nextCalibrationSample, stream);
            FfiConverterSequenceTypeCalibrationSample.INSTANCE.Write(value.@sampleHistory, stream);
    }
}



/// <summary>
/// Track information exposed via FFI
/// </summary>
public record TrackInfo (
    string @songId, 
    string @name, 
    string @artist, 
    string @album, 
    string @artworkUrl, 
    ulong @durationMs, 
    ulong @positionMs
) {
}

class FfiConverterTypeTrackInfo: FfiConverterRustBuffer<TrackInfo> {
    public static FfiConverterTypeTrackInfo INSTANCE = new FfiConverterTypeTrackInfo();

    public override TrackInfo Read(BigEndianStream stream) {
        return new TrackInfo(
            @songId: FfiConverterString.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream),
            @artist: FfiConverterString.INSTANCE.Read(stream),
            @album: FfiConverterString.INSTANCE.Read(stream),
            @artworkUrl: FfiConverterString.INSTANCE.Read(stream),
            @durationMs: FfiConverterUInt64.INSTANCE.Read(stream),
            @positionMs: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TrackInfo value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@songId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterString.INSTANCE.AllocationSize(value.@artist)
            + FfiConverterString.INSTANCE.AllocationSize(value.@album)
            + FfiConverterString.INSTANCE.AllocationSize(value.@artworkUrl)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@durationMs)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@positionMs);
    }

    public override void Write(TrackInfo value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@songId, stream);
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterString.INSTANCE.Write(value.@artist, stream);
            FfiConverterString.INSTANCE.Write(value.@album, stream);
            FfiConverterString.INSTANCE.Write(value.@artworkUrl, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@durationMs, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@positionMs, stream);
    }
}





/// <summary>
/// Error types exposed via FFI
/// </summary>
public class CoreException: UniffiException {
    CoreException() : base() {}
    CoreException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class CiderNotReachable : CoreException {
        public CiderNotReachable() : base() {}
    }
    
    
    
    public class CiderApiException : CoreException {
        // Members
        public string @v1;

        // Constructor
        public CiderApiException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class NetworkException : CoreException {
        // Members
        public string @v1;

        // Constructor
        public NetworkException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class NotInRoom : CoreException {
        public NotInRoom() : base() {}
    }
    
    
    
    public class AlreadyInRoom : CoreException {
        public AlreadyInRoom() : base() {}
    }
    
    
    
    public class NotHost : CoreException {
        public NotHost() : base() {}
    }
    
    
    
    public class JoinTimeout : CoreException {
        public JoinTimeout() : base() {}
    }
    
    

    
}

class FfiConverterTypeCoreError : FfiConverterRustBuffer<CoreException>, CallStatusErrorHandler<CoreException> {
    public static FfiConverterTypeCoreError INSTANCE = new FfiConverterTypeCoreError();

    public override CoreException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new CoreException.CiderNotReachable();
            case 2:
                return new CoreException.CiderApiException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new CoreException.NetworkException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new CoreException.NotInRoom();
            case 5:
                return new CoreException.AlreadyInRoom();
            case 6:
                return new CoreException.NotHost();
            case 7:
                return new CoreException.JoinTimeout();
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeCoreError.Read()", value));
        }
    }

    public override int AllocationSize(CoreException value) {
        switch (value) {

            case CoreException.CiderNotReachable variant_value:
                return 4;

            case CoreException.CiderApiException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case CoreException.NetworkException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case CoreException.NotInRoom variant_value:
                return 4;

            case CoreException.AlreadyInRoom variant_value:
                return 4;

            case CoreException.NotHost variant_value:
                return 4;

            case CoreException.JoinTimeout variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeCoreError.AllocationSize()", value));
        }
    }

    public override void Write(CoreException value, BigEndianStream stream) {
        switch (value) {
            case CoreException.CiderNotReachable variant_value:
                stream.WriteInt(1);
                break;
            case CoreException.CiderApiException variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case CoreException.NetworkException variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case CoreException.NotInRoom variant_value:
                stream.WriteInt(4);
                break;
            case CoreException.AlreadyInRoom variant_value:
                stream.WriteInt(5);
                break;
            case CoreException.NotHost variant_value:
                stream.WriteInt(6);
                break;
            case CoreException.JoinTimeout variant_value:
                stream.WriteInt(7);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeCoreError.Write()", value));
        }
    }
}



/// <summary>
/// Callback interface for session events
/// </summary>
public interface SessionCallback {
    void OnRoomStateChanged(RoomState @state);
    void OnTrackChanged(TrackInfo? @track);
    void OnPlaybackChanged(PlaybackState @playback);
    void OnParticipantJoined(Participant @participant);
    void OnParticipantLeft(string @peerId);
    void OnRoomEnded(string @reason);
    void OnError(string @message);
    void OnConnected();
    void OnDisconnected();
    /// <summary>
    /// Called periodically with sync status (listeners only)
    /// </summary>
    void OnSyncStatus(SyncStatus @status);
}

class UniffiCallbackInterfaceSessionCallback {
    static void OnRoomStateChanged(ulong @uniffiHandle,RustBuffer @state,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnRoomStateChanged(
                FfiConverterTypeRoomState.INSTANCE.Lift(@state));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnTrackChanged(ulong @uniffiHandle,RustBuffer @track,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnTrackChanged(
                FfiConverterOptionalTypeTrackInfo.INSTANCE.Lift(@track));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnPlaybackChanged(ulong @uniffiHandle,RustBuffer @playback,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnPlaybackChanged(
                FfiConverterTypePlaybackState.INSTANCE.Lift(@playback));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnParticipantJoined(ulong @uniffiHandle,RustBuffer @participant,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnParticipantJoined(
                FfiConverterTypeParticipant.INSTANCE.Lift(@participant));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnParticipantLeft(ulong @uniffiHandle,RustBuffer @peerId,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnParticipantLeft(
                FfiConverterString.INSTANCE.Lift(@peerId));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnRoomEnded(ulong @uniffiHandle,RustBuffer @reason,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnRoomEnded(
                FfiConverterString.INSTANCE.Lift(@reason));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnError(ulong @uniffiHandle,RustBuffer @message,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnError(
                FfiConverterString.INSTANCE.Lift(@message));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnConnected(ulong @uniffiHandle,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnConnected();
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnDisconnected(ulong @uniffiHandle,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnDisconnected();
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnSyncStatus(ulong @uniffiHandle,RustBuffer @status,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSessionCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnSyncStatus(
                FfiConverterTypeSyncStatus.INSTANCE.Lift(@status));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeSessionCallback.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod0(OnRoomStateChanged);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod1(OnTrackChanged);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod2 _m2 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod2(OnPlaybackChanged);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod3 _m3 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod3(OnParticipantJoined);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod4 _m4 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod4(OnParticipantLeft);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod5 _m5 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod5(OnRoomEnded);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod6 _m6 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod6(OnError);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod7 _m7 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod7(OnConnected);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod8 _m8 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod8(OnDisconnected);
    static _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod9 _m9 = new _UniFFILib.UniffiCallbackInterfaceSessionCallbackMethod9(OnSyncStatus);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static _UniFFILib.UniffiVTableCallbackInterfaceSessionCallback _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceSessionCallback {
        @onRoomStateChanged = Marshal.GetFunctionPointerForDelegate(_m0),
        @onTrackChanged = Marshal.GetFunctionPointerForDelegate(_m1),
        @onPlaybackChanged = Marshal.GetFunctionPointerForDelegate(_m2),
        @onParticipantJoined = Marshal.GetFunctionPointerForDelegate(_m3),
        @onParticipantLeft = Marshal.GetFunctionPointerForDelegate(_m4),
        @onRoomEnded = Marshal.GetFunctionPointerForDelegate(_m5),
        @onError = Marshal.GetFunctionPointerForDelegate(_m6),
        @onConnected = Marshal.GetFunctionPointerForDelegate(_m7),
        @onDisconnected = Marshal.GetFunctionPointerForDelegate(_m8),
        @onSyncStatus = Marshal.GetFunctionPointerForDelegate(_m9),
        @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
    };

    public static void Register() {
        _UniFFILib.uniffi_cider_core_fn_init_callback_vtable_sessioncallback(ref UniffiCallbackInterfaceSessionCallback._vtable);
    }
}

class ConcurrentHandleMap<T> where T: notnull {
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj) {
        lock (lock_) {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result) {
        lock (lock_) {
            #pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
            #pragma warning restore 8601
        }
    }

    public T Get(ulong handle) {
        if (TryGet(handle, out var result)) {
            return result;
        } else {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle) {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result) {
        lock (lock_) {
            // Possible null reference assignment
            #pragma warning disable 8601
            if (map.TryGetValue(handle, out result)) {
            #pragma warning restore 8601
                map.Remove(handle);
                return true;
            } else {
                return false;
            }
        }
    }
}
static class UniffiCallbackResponseStatus {
    public static sbyte SUCCESS = 0;
    public static sbyte ERROR = 1;
    public static sbyte UNEXPECTED_ERROR = 2;
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeSessionCallback: FfiConverter<SessionCallback, ulong> {
    public static FfiConverterTypeSessionCallback INSTANCE = new FfiConverterTypeSessionCallback();

    public ConcurrentHandleMap<SessionCallback> handleMap = new ConcurrentHandleMap<SessionCallback>();

    public override ulong Lower(SessionCallback value) {
        return handleMap.Insert(value);
    }

    public override SessionCallback Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override SessionCallback Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(SessionCallback value) {
        return 8;
    }

    public override void Write(SessionCallback value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}




class FfiConverterOptionalInt64: FfiConverterRustBuffer<long?> {
    public static FfiConverterOptionalInt64 INSTANCE = new FfiConverterOptionalInt64();

    public override long? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(long? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterInt64.INSTANCE.AllocationSize((long)value);
        }
    }

    public override void Write(long? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterInt64.INSTANCE.Write((long)value, stream);
        }
    }
}




class FfiConverterOptionalString: FfiConverterRustBuffer<string?> {
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}




class FfiConverterOptionalTypeRoomState: FfiConverterRustBuffer<RoomState?> {
    public static FfiConverterOptionalTypeRoomState INSTANCE = new FfiConverterOptionalTypeRoomState();

    public override RoomState? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeRoomState.INSTANCE.Read(stream);
    }

    public override int AllocationSize(RoomState? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeRoomState.INSTANCE.AllocationSize((RoomState)value);
        }
    }

    public override void Write(RoomState? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeRoomState.INSTANCE.Write((RoomState)value, stream);
        }
    }
}




class FfiConverterOptionalTypeTrackInfo: FfiConverterRustBuffer<TrackInfo?> {
    public static FfiConverterOptionalTypeTrackInfo INSTANCE = new FfiConverterOptionalTypeTrackInfo();

    public override TrackInfo? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeTrackInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TrackInfo? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeTrackInfo.INSTANCE.AllocationSize((TrackInfo)value);
        }
    }

    public override void Write(TrackInfo? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeTrackInfo.INSTANCE.Write((TrackInfo)value, stream);
        }
    }
}




class FfiConverterSequenceTypeCalibrationSample: FfiConverterRustBuffer<CalibrationSample[]> {
    public static FfiConverterSequenceTypeCalibrationSample INSTANCE = new FfiConverterSequenceTypeCalibrationSample();

    public override CalibrationSample[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new CalibrationSample[(length)];
        var readFn = FfiConverterTypeCalibrationSample.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(CalibrationSample[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeCalibrationSample.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(CalibrationSample[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeCalibrationSample.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeParticipant: FfiConverterRustBuffer<Participant[]> {
    public static FfiConverterSequenceTypeParticipant INSTANCE = new FfiConverterSequenceTypeParticipant();

    public override Participant[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Participant[(length)];
        var readFn = FfiConverterTypeParticipant.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Participant[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeParticipant.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Participant[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeParticipant.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}
#pragma warning restore 8625
internal static class CiderCoreMethods {
}


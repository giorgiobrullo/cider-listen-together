// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(cider_coreFFI)
    import cider_coreFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_cider_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_cider_core_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

/**
 * Main session interface
 */
public protocol SessionProtocol: AnyObject {
    /**
     * Broadcast current playback state to room (for host heartbeat)
     */
    func broadcastPlayback(track: TrackInfo?, isPlaying: Bool, positionMs: UInt64) throws

    /**
     * Broadcast track change to room (for host when track changes)
     */
    func broadcastTrackChange(track: TrackInfo, positionMs: UInt64) throws

    /**
     * Check if Cider is reachable
     */
    func checkCiderConnection() throws

    /**
     * Create a new room (become host)
     */
    func createRoom(displayName: String) throws -> String

    /**
     * Check if Cider is currently playing
     */
    func getIsPlaying() throws -> Bool

    /**
     * Get the currently playing track from Cider
     */
    func getNowPlaying() throws -> TrackInfo?

    /**
     * Get playback state (track info + is_playing) in a single call
     */
    func getPlaybackState() throws -> CurrentPlayback

    /**
     * Get current room state
     */
    func getRoomState() -> RoomState?

    /**
     * Check if we are the host
     */
    func isHost() -> Bool

    /**
     * Check if we are in a room
     */
    func isInRoom() -> Bool

    /**
     * Join an existing room
     */
    func joinRoom(roomCode: String, displayName: String) throws

    /**
     * Leave the current room
     */
    func leaveRoom() throws

    /**
     * Set the event callback
     */
    func setCallback(callback: SessionCallback)

    /**
     * Set the Cider API token
     */
    func setCiderToken(token: String?)

    /**
     * Sync next command (host only)
     */
    func syncNext() throws

    /**
     * Sync pause command (host only)
     */
    func syncPause() throws

    /**
     * Sync play command (host only)
     */
    func syncPlay() throws

    /**
     * Sync previous command (host only)
     */
    func syncPrevious() throws

    /**
     * Sync seek command (host only)
     */
    func syncSeek(positionMs: UInt64) throws

    /**
     * Transfer host to another peer
     */
    func transferHost(peerId: String) throws
}

/**
 * Main session interface
 */
open class Session:
    SessionProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cider_core_fn_clone_session(self.pointer, $0) }
    }

    /**
     * Create a new session
     */
    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cider_core_fn_constructor_session_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cider_core_fn_free_session(pointer, $0) }
    }

    /**
     * Broadcast current playback state to room (for host heartbeat)
     */
    open func broadcastPlayback(track: TrackInfo?, isPlaying: Bool, positionMs: UInt64) throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_broadcast_playback(self.uniffiClonePointer(),
                                                               FfiConverterOptionTypeTrackInfo.lower(track),
                                                               FfiConverterBool.lower(isPlaying),
                                                               FfiConverterUInt64.lower(positionMs), $0)
    }
    }

    /**
     * Broadcast track change to room (for host when track changes)
     */
    open func broadcastTrackChange(track: TrackInfo, positionMs: UInt64) throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_broadcast_track_change(self.uniffiClonePointer(),
                                                                   FfiConverterTypeTrackInfo.lower(track),
                                                                   FfiConverterUInt64.lower(positionMs), $0)
    }
    }

    /**
     * Check if Cider is reachable
     */
    open func checkCiderConnection() throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_check_cider_connection(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Create a new room (become host)
     */
    open func createRoom(displayName: String) throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeCoreError.lift) {
            uniffi_cider_core_fn_method_session_create_room(self.uniffiClonePointer(),
                                                            FfiConverterString.lower(displayName), $0)
        })
    }

    /**
     * Check if Cider is currently playing
     */
    open func getIsPlaying() throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeCoreError.lift) {
            uniffi_cider_core_fn_method_session_get_is_playing(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Get the currently playing track from Cider
     */
    open func getNowPlaying() throws -> TrackInfo? {
        return try FfiConverterOptionTypeTrackInfo.lift(rustCallWithError(FfiConverterTypeCoreError.lift) {
            uniffi_cider_core_fn_method_session_get_now_playing(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Get playback state (track info + is_playing) in a single call
     */
    open func getPlaybackState() throws -> CurrentPlayback {
        return try FfiConverterTypeCurrentPlayback.lift(rustCallWithError(FfiConverterTypeCoreError.lift) {
            uniffi_cider_core_fn_method_session_get_playback_state(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Get current room state
     */
    open func getRoomState() -> RoomState? {
        return try! FfiConverterOptionTypeRoomState.lift(try! rustCall {
            uniffi_cider_core_fn_method_session_get_room_state(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Check if we are the host
     */
    open func isHost() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cider_core_fn_method_session_is_host(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Check if we are in a room
     */
    open func isInRoom() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cider_core_fn_method_session_is_in_room(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Join an existing room
     */
    open func joinRoom(roomCode: String, displayName: String) throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_join_room(self.uniffiClonePointer(),
                                                      FfiConverterString.lower(roomCode),
                                                      FfiConverterString.lower(displayName), $0)
    }
    }

    /**
     * Leave the current room
     */
    open func leaveRoom() throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_leave_room(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Set the event callback
     */
    open func setCallback(callback: SessionCallback) { try! rustCall {
        uniffi_cider_core_fn_method_session_set_callback(self.uniffiClonePointer(),
                                                         FfiConverterCallbackInterfaceSessionCallback.lower(callback), $0)
    }
    }

    /**
     * Set the Cider API token
     */
    open func setCiderToken(token: String?) { try! rustCall {
        uniffi_cider_core_fn_method_session_set_cider_token(self.uniffiClonePointer(),
                                                            FfiConverterOptionString.lower(token), $0)
    }
    }

    /**
     * Sync next command (host only)
     */
    open func syncNext() throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_sync_next(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Sync pause command (host only)
     */
    open func syncPause() throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_sync_pause(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Sync play command (host only)
     */
    open func syncPlay() throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_sync_play(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Sync previous command (host only)
     */
    open func syncPrevious() throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_sync_previous(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Sync seek command (host only)
     */
    open func syncSeek(positionMs: UInt64) throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_sync_seek(self.uniffiClonePointer(),
                                                      FfiConverterUInt64.lower(positionMs), $0)
    }
    }

    /**
     * Transfer host to another peer
     */
    open func transferHost(peerId: String) throws { try rustCallWithError(FfiConverterTypeCoreError.lift) {
        uniffi_cider_core_fn_method_session_transfer_host(self.uniffiClonePointer(),
                                                          FfiConverterString.lower(peerId), $0)
    }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSession: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Session

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
        return Session(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Session) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
    return try FfiConverterTypeSession.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lower(_ value: Session) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSession.lower(value)
}

/**
 * Current playback info (for polling) exposed via FFI
 */
public struct CurrentPlayback {
    public var track: TrackInfo?
    public var isPlaying: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(track: TrackInfo?, isPlaying: Bool) {
        self.track = track
        self.isPlaying = isPlaying
    }
}

extension CurrentPlayback: Equatable, Hashable {
    public static func == (lhs: CurrentPlayback, rhs: CurrentPlayback) -> Bool {
        if lhs.track != rhs.track {
            return false
        }
        if lhs.isPlaying != rhs.isPlaying {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(track)
        hasher.combine(isPlaying)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCurrentPlayback: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurrentPlayback {
        return
            try CurrentPlayback(
                track: FfiConverterOptionTypeTrackInfo.read(from: &buf),
                isPlaying: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: CurrentPlayback, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTrackInfo.write(value.track, into: &buf)
        FfiConverterBool.write(value.isPlaying, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrentPlayback_lift(_ buf: RustBuffer) throws -> CurrentPlayback {
    return try FfiConverterTypeCurrentPlayback.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrentPlayback_lower(_ value: CurrentPlayback) -> RustBuffer {
    return FfiConverterTypeCurrentPlayback.lower(value)
}

/**
 * Participant exposed via FFI
 */
public struct Participant {
    public var peerId: String
    public var displayName: String
    public var isHost: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(peerId: String, displayName: String, isHost: Bool) {
        self.peerId = peerId
        self.displayName = displayName
        self.isHost = isHost
    }
}

extension Participant: Equatable, Hashable {
    public static func == (lhs: Participant, rhs: Participant) -> Bool {
        if lhs.peerId != rhs.peerId {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.isHost != rhs.isHost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(peerId)
        hasher.combine(displayName)
        hasher.combine(isHost)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeParticipant: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Participant {
        return
            try Participant(
                peerId: FfiConverterString.read(from: &buf),
                displayName: FfiConverterString.read(from: &buf),
                isHost: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: Participant, into buf: inout [UInt8]) {
        FfiConverterString.write(value.peerId, into: &buf)
        FfiConverterString.write(value.displayName, into: &buf)
        FfiConverterBool.write(value.isHost, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipant_lift(_ buf: RustBuffer) throws -> Participant {
    return try FfiConverterTypeParticipant.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeParticipant_lower(_ value: Participant) -> RustBuffer {
    return FfiConverterTypeParticipant.lower(value)
}

/**
 * Playback state exposed via FFI
 */
public struct PlaybackState {
    public var isPlaying: Bool
    public var positionMs: UInt64
    public var timestampMs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isPlaying: Bool, positionMs: UInt64, timestampMs: UInt64) {
        self.isPlaying = isPlaying
        self.positionMs = positionMs
        self.timestampMs = timestampMs
    }
}

extension PlaybackState: Equatable, Hashable {
    public static func == (lhs: PlaybackState, rhs: PlaybackState) -> Bool {
        if lhs.isPlaying != rhs.isPlaying {
            return false
        }
        if lhs.positionMs != rhs.positionMs {
            return false
        }
        if lhs.timestampMs != rhs.timestampMs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isPlaying)
        hasher.combine(positionMs)
        hasher.combine(timestampMs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePlaybackState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlaybackState {
        return
            try PlaybackState(
                isPlaying: FfiConverterBool.read(from: &buf),
                positionMs: FfiConverterUInt64.read(from: &buf),
                timestampMs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PlaybackState, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isPlaying, into: &buf)
        FfiConverterUInt64.write(value.positionMs, into: &buf)
        FfiConverterUInt64.write(value.timestampMs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePlaybackState_lift(_ buf: RustBuffer) throws -> PlaybackState {
    return try FfiConverterTypePlaybackState.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePlaybackState_lower(_ value: PlaybackState) -> RustBuffer {
    return FfiConverterTypePlaybackState.lower(value)
}

/**
 * Room state exposed via FFI
 */
public struct RoomState {
    public var roomCode: String
    public var localPeerId: String
    public var hostPeerId: String
    public var participants: [Participant]
    public var currentTrack: TrackInfo?
    public var playback: PlaybackState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roomCode: String, localPeerId: String, hostPeerId: String, participants: [Participant], currentTrack: TrackInfo?, playback: PlaybackState) {
        self.roomCode = roomCode
        self.localPeerId = localPeerId
        self.hostPeerId = hostPeerId
        self.participants = participants
        self.currentTrack = currentTrack
        self.playback = playback
    }
}

extension RoomState: Equatable, Hashable {
    public static func == (lhs: RoomState, rhs: RoomState) -> Bool {
        if lhs.roomCode != rhs.roomCode {
            return false
        }
        if lhs.localPeerId != rhs.localPeerId {
            return false
        }
        if lhs.hostPeerId != rhs.hostPeerId {
            return false
        }
        if lhs.participants != rhs.participants {
            return false
        }
        if lhs.currentTrack != rhs.currentTrack {
            return false
        }
        if lhs.playback != rhs.playback {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(roomCode)
        hasher.combine(localPeerId)
        hasher.combine(hostPeerId)
        hasher.combine(participants)
        hasher.combine(currentTrack)
        hasher.combine(playback)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomState {
        return
            try RoomState(
                roomCode: FfiConverterString.read(from: &buf),
                localPeerId: FfiConverterString.read(from: &buf),
                hostPeerId: FfiConverterString.read(from: &buf),
                participants: FfiConverterSequenceTypeParticipant.read(from: &buf),
                currentTrack: FfiConverterOptionTypeTrackInfo.read(from: &buf),
                playback: FfiConverterTypePlaybackState.read(from: &buf)
            )
    }

    public static func write(_ value: RoomState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomCode, into: &buf)
        FfiConverterString.write(value.localPeerId, into: &buf)
        FfiConverterString.write(value.hostPeerId, into: &buf)
        FfiConverterSequenceTypeParticipant.write(value.participants, into: &buf)
        FfiConverterOptionTypeTrackInfo.write(value.currentTrack, into: &buf)
        FfiConverterTypePlaybackState.write(value.playback, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomState_lift(_ buf: RustBuffer) throws -> RoomState {
    return try FfiConverterTypeRoomState.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomState_lower(_ value: RoomState) -> RustBuffer {
    return FfiConverterTypeRoomState.lower(value)
}

/**
 * Sync status for debug display
 */
public struct SyncStatus {
    /**
     * Drift in milliseconds (positive = ahead of host, negative = behind)
     */
    public var driftMs: Int64
    /**
     * One-way latency to host in milliseconds
     */
    public var latencyMs: UInt64
    /**
     * Time elapsed since host's heartbeat timestamp
     */
    public var elapsedMs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Drift in milliseconds (positive = ahead of host, negative = behind)
         */ driftMs: Int64,
        /**
            * One-way latency to host in milliseconds
            */ latencyMs: UInt64,
        /**
            * Time elapsed since host's heartbeat timestamp
            */ elapsedMs: UInt64
    ) {
        self.driftMs = driftMs
        self.latencyMs = latencyMs
        self.elapsedMs = elapsedMs
    }
}

extension SyncStatus: Equatable, Hashable {
    public static func == (lhs: SyncStatus, rhs: SyncStatus) -> Bool {
        if lhs.driftMs != rhs.driftMs {
            return false
        }
        if lhs.latencyMs != rhs.latencyMs {
            return false
        }
        if lhs.elapsedMs != rhs.elapsedMs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(driftMs)
        hasher.combine(latencyMs)
        hasher.combine(elapsedMs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncStatus {
        return
            try SyncStatus(
                driftMs: FfiConverterInt64.read(from: &buf),
                latencyMs: FfiConverterUInt64.read(from: &buf),
                elapsedMs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: SyncStatus, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.driftMs, into: &buf)
        FfiConverterUInt64.write(value.latencyMs, into: &buf)
        FfiConverterUInt64.write(value.elapsedMs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncStatus_lift(_ buf: RustBuffer) throws -> SyncStatus {
    return try FfiConverterTypeSyncStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncStatus_lower(_ value: SyncStatus) -> RustBuffer {
    return FfiConverterTypeSyncStatus.lower(value)
}

/**
 * Track information exposed via FFI
 */
public struct TrackInfo {
    public var songId: String
    public var name: String
    public var artist: String
    public var album: String
    public var artworkUrl: String
    public var durationMs: UInt64
    public var positionMs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(songId: String, name: String, artist: String, album: String, artworkUrl: String, durationMs: UInt64, positionMs: UInt64) {
        self.songId = songId
        self.name = name
        self.artist = artist
        self.album = album
        self.artworkUrl = artworkUrl
        self.durationMs = durationMs
        self.positionMs = positionMs
    }
}

extension TrackInfo: Equatable, Hashable {
    public static func == (lhs: TrackInfo, rhs: TrackInfo) -> Bool {
        if lhs.songId != rhs.songId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.artist != rhs.artist {
            return false
        }
        if lhs.album != rhs.album {
            return false
        }
        if lhs.artworkUrl != rhs.artworkUrl {
            return false
        }
        if lhs.durationMs != rhs.durationMs {
            return false
        }
        if lhs.positionMs != rhs.positionMs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(songId)
        hasher.combine(name)
        hasher.combine(artist)
        hasher.combine(album)
        hasher.combine(artworkUrl)
        hasher.combine(durationMs)
        hasher.combine(positionMs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrackInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackInfo {
        return
            try TrackInfo(
                songId: FfiConverterString.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                artist: FfiConverterString.read(from: &buf),
                album: FfiConverterString.read(from: &buf),
                artworkUrl: FfiConverterString.read(from: &buf),
                durationMs: FfiConverterUInt64.read(from: &buf),
                positionMs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: TrackInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.songId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.artist, into: &buf)
        FfiConverterString.write(value.album, into: &buf)
        FfiConverterString.write(value.artworkUrl, into: &buf)
        FfiConverterUInt64.write(value.durationMs, into: &buf)
        FfiConverterUInt64.write(value.positionMs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackInfo_lift(_ buf: RustBuffer) throws -> TrackInfo {
    return try FfiConverterTypeTrackInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackInfo_lower(_ value: TrackInfo) -> RustBuffer {
    return FfiConverterTypeTrackInfo.lower(value)
}

/**
 * Error types exposed via FFI
 */
public enum CoreError {
    case CiderNotReachable
    case CiderApiError(String
    )
    case NetworkError(String
    )
    case NotInRoom
    case AlreadyInRoom
    case NotHost
    case JoinTimeout
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoreError: FfiConverterRustBuffer {
    typealias SwiftType = CoreError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoreError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .CiderNotReachable
        case 2: return try .CiderApiError(
                FfiConverterString.read(from: &buf)
            )
        case 3: return try .NetworkError(
                FfiConverterString.read(from: &buf)
            )
        case 4: return .NotInRoom
        case 5: return .AlreadyInRoom
        case 6: return .NotHost
        case 7: return .JoinTimeout
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoreError, into buf: inout [UInt8]) {
        switch value {
        case .CiderNotReachable:
            writeInt(&buf, Int32(1))

        case let .CiderApiError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .NetworkError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case .NotInRoom:
            writeInt(&buf, Int32(4))

        case .AlreadyInRoom:
            writeInt(&buf, Int32(5))

        case .NotHost:
            writeInt(&buf, Int32(6))

        case .JoinTimeout:
            writeInt(&buf, Int32(7))
        }
    }
}

extension CoreError: Equatable, Hashable {}

extension CoreError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

/**
 * Callback interface for session events
 */
public protocol SessionCallback: AnyObject {
    func onRoomStateChanged(state: RoomState)

    func onTrackChanged(track: TrackInfo?)

    func onPlaybackChanged(playback: PlaybackState)

    func onParticipantJoined(participant: Participant)

    func onParticipantLeft(peerId: String)

    func onRoomEnded(reason: String)

    func onError(message: String)

    func onConnected()

    func onDisconnected()

    /**
     * Called periodically with sync status (listeners only)
     */
    func onSyncStatus(status: SyncStatus)
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceSessionCallback {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSessionCallback = .init(
        onRoomStateChanged: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onRoomStateChanged(
                    state: FfiConverterTypeRoomState.lift(state)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onTrackChanged: { (
            uniffiHandle: UInt64,
            track: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onTrackChanged(
                    track: FfiConverterOptionTypeTrackInfo.lift(track)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onPlaybackChanged: { (
            uniffiHandle: UInt64,
            playback: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onPlaybackChanged(
                    playback: FfiConverterTypePlaybackState.lift(playback)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onParticipantJoined: { (
            uniffiHandle: UInt64,
            participant: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onParticipantJoined(
                    participant: FfiConverterTypeParticipant.lift(participant)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onParticipantLeft: { (
            uniffiHandle: UInt64,
            peerId: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onParticipantLeft(
                    peerId: FfiConverterString.lift(peerId)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onRoomEnded: { (
            uniffiHandle: UInt64,
            reason: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onRoomEnded(
                    reason: FfiConverterString.lift(reason)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onError(
                    message: FfiConverterString.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onConnected: { (
            uniffiHandle: UInt64,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConnected(
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onDisconnected: { (
            uniffiHandle: UInt64,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onDisconnected(
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onSyncStatus: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onSyncStatus(
                    status: FfiConverterTypeSyncStatus.lift(status)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceSessionCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SessionCallback: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSessionCallback() {
    uniffi_cider_core_fn_init_callback_vtable_sessioncallback(&UniffiCallbackInterfaceSessionCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private enum FfiConverterCallbackInterfaceSessionCallback {
    fileprivate static var handleMap = UniffiHandleMap<SessionCallback>()
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSessionCallback: FfiConverter {
    typealias SwiftType = SessionCallback
    typealias FfiType = UInt64

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeRoomState: FfiConverterRustBuffer {
    typealias SwiftType = RoomState?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomState.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeTrackInfo: FfiConverterRustBuffer {
    typealias SwiftType = TrackInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTrackInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTrackInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeParticipant: FfiConverterRustBuffer {
    typealias SwiftType = [Participant]

    static func write(_ value: [Participant], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParticipant.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Participant] {
        let len: Int32 = try readInt(&buf)
        var seq = [Participant]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeParticipant.read(from: &buf))
        }
        return seq
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_cider_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_cider_core_checksum_method_session_broadcast_playback() != 49795 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_broadcast_track_change() != 36013 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_check_cider_connection() != 54359 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_create_room() != 63668 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_get_is_playing() != 24018 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_get_now_playing() != 24844 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_get_playback_state() != 29211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_get_room_state() != 61756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_is_host() != 23213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_is_in_room() != 49720 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_join_room() != 19987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_leave_room() != 60146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_set_callback() != 55902 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_set_cider_token() != 49915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_sync_next() != 18357 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_sync_pause() != 6232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_sync_play() != 24935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_sync_previous() != 26314 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_sync_seek() != 54577 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_session_transfer_host() != 44133 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_constructor_session_new() != 7363 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_room_state_changed() != 37933 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_track_changed() != 7828 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_playback_changed() != 28967 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_participant_joined() != 28402 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_participant_left() != 25130 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_room_ended() != 12494 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_error() != 33220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_connected() != 25547 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_disconnected() != 6877 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cider_core_checksum_method_sessioncallback_on_sync_status() != 16815 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitSessionCallback()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
